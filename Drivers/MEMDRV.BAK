{$IFDEF debug}
  {$A-,B-,D+,E+,F+,G-,I+,L+,N+,M 16384 0 655360,O-,P+,Q+,R+,S+,T-,V-,X+,Y+}
{$ELSE}
  {$A-,B-,D-,E+,F+,G-,I+,L-,N+,M 16384 0 655360,O-,P+,Q-,R-,S-,T-,V-,X+,Y-}
{$ENDIF}
unit MemDrv;

interface

uses
  Objects,
  Except,
  Common,
  Collects,
  Dos;

const
  MaxVarSize = $FFF0;

type
  PReferenceList = ^TReferenceList;
  PReference = ^TReference;

  TReferenceList = object(TList)
    destructor Free; virtual;
    function GetItem(AIndex: integer): PReference;
    function IndexOf(AItem: PReference): integer;
    function Add(AItem: PReference): integer;
    function GetTypeName: string; virtual;
    procedure Clear; virtual;
    procedure Insert(AIndex: integer; AItem: PReference);
  end;

  TReferenceType =
  (
    Conventional,
    Xms
  );

  TReference = record
    Xms: boolean;
    Size: longint;
    Offset: longint;
  end;

  TLowerPointer = record
    Reference: PReference;
    Offset: word;
  end;

  PMemoryDriver = ^TMemoryDriver;
  TMemoryDriver = object(TExceptionObject)
  private
    FReferences: PReferenceList;
    FCurrentReference: PReference;
    FXmsEnabled: boolean;
    FXmsVersion: real;
    FXmsHandle: word;
    FXmsLowerMemorySize: longint;
    FBuffer: PByte;
    FSwapSize: longint;
    FLowerAllocated: longint;
    FXmsAllocated: longint;
    FXmsSize: longint;
    FTransactionReferences: PReferenceList;
    function GetXmsControlFunction: pointer; virtual;
    function GetNextOffset(ASize: longint; AXms: boolean): longint; virtual;
    function XmsAlloc(ASize: longint): word; virtual;
    function MaxAvail(AXms: boolean): longint; virtual;
    procedure MoveReference(AReference: PReference; var AMoveRecord); virtual;
    procedure MoveToConventional(AReference: PReference); virtual;
  public
    constructor Create(ASize: longint);
    destructor Free; virtual;
    function XmsSupported: boolean;
    function XmsEnabled: boolean; virtual;
    function XmsMemAvail: longint; virtual;
    function XmsMaxAvail: longint; virtual;
    function LowerMaxAvail: longint; virtual;
    function LowerMemAvail: longint; virtual;
    function XmsVersion: real;
    function References: PReferenceList;
    function SwapSize: longint;
    function Buffer: PByte;
    function CurrentReference: PReference;
    function GetTypeName: string; virtual;
    function ReferencePointer(AReference: PReference): pointer;
    function Alloc(ASize: longint): Preference;
    procedure InitXms;
    procedure Init; virtual;
    procedure SetCurrentReference (AReference: PReference); virtual;
    procedure Dealloc(var AReference: PReference); virtual;
    procedure BeginAllocTransaction; virtual;
    procedure CommitAllocTransaction; virtual;
    procedure RollbackAllocTransaction; virtual;
    procedure FreeReference(AReference: PReference); virtual;
    procedure Fill(AReference: PReference; AByte: byte); virtual;
  end;

var
  Memory: TMemoryDriver;
  OutOfMemoryException: PException;

function OnHeapError(size: word): integer; far;

implementation

const
  HiWord = 1;
  LoWord = 2;

type
  PXmsMoveRecord = ^TXmsMoveRecord;
  TXmsMoveRecord = record
    Length: longint;
    SourceHandle: word;
    SourceOffset: array[hiWord..loWord] of word;
    DestHandle: word;
    DestOffset: array[hiWord..loWord] of word;
  end;

var
  XmsControl: pointer;

function ReferenceOffsetCompare(item1, item2: pointer): integer; far;
var
  ref1, ref2: TReference;
  result: integer;
begin
  ref1 := PReference(item1)^;
  ref2 := PReference(item2)^;
  result := 0;
  if (ref1.Offset < ref2.Offset) then
    result := -1
  else if (ref1.Offset > ref2.Offset) then
    result := 1;
  ReferenceOffsetCompare := result;
end;

function OnHeapError(size: word): integer;
begin
  OnHeapError := 1;
end;

function IsXms(item: pointer; var value): boolean; far;
begin
  IsXms   := PReference(item)^.Xms = boolean(value);
end;

constructor TMemoryDriver.Create(ASize: longint);
begin
  FSwapSize := ASize;
  inherited Create;
{  HugeGetMem(pointer(FBuffer), FBufferSize);
  if FBuffer = nil then
    Raise(ecNotEnoughMemory);}
end;

function TMemoryDriver.References: PReferenceList;
begin
  References := FReferences;
end;

function TMemoryDriver.SwapSize: longint;
begin
  SwapSize := FSwapSize;
end;

function TMemoryDriver.XmsEnabled: boolean;
begin
  XmsEnabled := FXmsEnabled;
end;

function TMemoryDriver.XmsSupported: boolean;
var
  reg: Registers;
  result: byte;
begin
  asm
    mov ax, 4300h
    int 2Fh
    mov [result], al
  end;
  XmsSupported := result = $80;
end;

procedure TMemoryDriver.InitXms;
var
  version: word;
  revision: word;
  code: integer;
  hex: string;
  xmsHandle: word;
  xmsError: byte;
  xmsAllocated: word;
  size: word;
  kbytes: word;
  {$IFDEF debug}
  filename: string;
  debugFile: File;
  {$ENDIF}
begin
  FXmsEnabled := false;
  if XmsSupported then begin
    {$IFDEF debug}
    filename := 'XmsDebug.bin';
    if FileExists(filename) then begin
      System.Assign(debugFile, filename);
      Reset(debugFile, 1);
      BlockRead(debugFile, xmsHandle, SizeOf(xmsHandle));
      System.Close(debugFile);
      XmsControl := GetXmsControlFunction;
      asm
        mov ah, 0Ah
        mov dx, [xmsHandle]
        call [XmsControl]
      end;
    end;
    {$ENDIF}

    XmsControl := GetXmsControlFunction;
    if XmsControl = nil then
      exit;
    asm
      { Initialize XMS }
      mov ah, 00h
      call [XmsControl]
      mov [version], ax
      mov [revision], bx

      { Get max XMS available }
      mov ah, 08h
      call [XmsControl]
      mov [kbytes], dx
    end;
    size := FSwapSize;
    asm
      mov ah, 09h
      mov dx, [size]
      call [XmsControl]
      mov [xmsHandle], dx
      mov [xmsAllocated], ax
      mov [xmsError], bl
    end;
    FXmsSize := longint(size) * 1024;
    if (xmsError > 0) or (xmsAllocated = 0) then
      exit;
    FXmsHandle := xmsHandle;
    FXmsEnabled := true;
    hex := Copy(IntToHex(revision),  3, 3);
    Val(hex, FXmsVersion, code);
    FXmsVersion := FXmsVersion / 100;
    {$IFDEF debug}
      System.Assign(debugFile, filename);
      Rewrite(debugFile, 1);
      BlockWrite(debugFile, FXmsHandle, SizeOf(FXmsHandle));
      Close(debugFile);
    {$ENDIF}
  end;
end;

function TMemoryDriver.GetNextOffset(ASize: longint; AXms: boolean): longint;
var
  index: integer;
  offset: longint;
  reference: PReference;
  filtered: PList;
  count: integer;
begin
  offset := 0;
  GetNextOffset := 0;
  if FReferences^.Count = 0 then
    exit;
  for index := 0 to FReferences^.Count - 1 do begin
    reference := FReferences^.GetItem(index);
    if (AXms and not reference^.Xms) or ((not AXms) and reference^.Xms) then
      continue;
    if offset + ASize > FSwapSize - 1 then begin
      Raise(ecNotEnoughMemory);
      exit;
    end;
    if offset + ASize < reference^.Offset then
      break;
    Inc(offset, reference^.Size);
  end;
  GetNextOffset := offset;
end;

function TMemoryDriver.GetXmsControlFunction: pointer;
var
  result: pointer;
begin
  asm
    push es
    mov ax, 4310h
    int 2Fh
    mov word ptr [result], bx
    mov word ptr [result + 2], es
    pop es
  end;
  GetXmsControlFunction := result;
end;

function TMemoryDriver.CurrentReference: PReference;
begin
  CurrentReference := FCurrentReference;
end;

procedure TMemoryDriver.MoveReference(AReference: PReference; var AMoveRecord);
var
  result: word;
  xmsError: byte;
  segm, offs: word;
begin
  segm := Seg(AMoveRecord);
  offs := Ofs(AMoveRecord);
  segm := Seg(XmsControl);
  asm
    push    ds
    push    si
    mov     ah, 0bh
    mov     ds, [segm]
    mov     si, [offs]
    call    [XmsControl]
    mov     [result], ax
    mov     [xmsError], bl
    pop     si
    pop     ds
  end;
  if result <> 1 then
    Raise(ecXmsError);
end;

procedure TMemoryDriver.MoveToConventional(AReference: PReference);
var
  xmsMoveRecord: TXmsMoveRecord;
  xmsHandle: word;
  xmsError: byte;
  index: integer;
  current: PReference;
  count: integer;
  offset: longint;
  dest: longint;
begin
  { If there is not enough conventional memory, purge references until there is }
  while LowerMaxAvail < AReference^.Size do begin
    if FReferences^.Count = 0 then begin
      Raise(ecNotEnoughMemory);
      exit;
    end;
    index := 0;
    count := FReferences^.Count;
    while (index < count) and (LowerMaxAvail < AReference^.Size) do begin
      current := FReferences^.GetItem(index);
      if current^.Xms then begin
        Inc(index);
        continue;
      end;
      with xmsMoveRecord do begin
        Length := current^.Size;
        SourceHandle := 0;
        SourceOffset[HiWord] := Ofs(current^.Offset);
        SourceOffset[LoWord] := Seg(current^.Offset);
        DestHandle := FXmsHandle;
        offset := GetNextOffset(current^.Size, true);
        DestOffset[HiWord] := Ofs(offset);
        DestOffset[LoWord] := Seg(offset);
      end;
      MoveReference(current, xmsMoveRecord);
      if HasException then
        exit;
      Dec(FLowerAllocated, current^.Size);
      AReference^.Xms := true;
      current^.Offset := 0;
      Inc(index);
    end;
  end;

  { Allocate conventional memory for the reference }
  dest := GetNextOffset(AReference^.Size, false);
  Inc(FLowerAllocated, AReference^.Size);

  { Move to conventional memory }
  with xmsMoveRecord do begin
    Length := AReference^.Size;
    SourceHandle := FXmsHandle;
    SourceOffset[HiWord] := Ofs(AReference^.Offset);
    SourceOffset[LoWord] := Seg(AReference^.Offset);
    DestHandle := 0;
    DestOffset[HiWord] := Ofs(dest);
    DestOffset[LoWord] := Seg(dest);
  end;
  MoveReference(AReference, xmsMoveRecord);
  Dec(FXmsAllocated, AReference^.Size);
  AReference^.Offset := dest;
  AReference^.Xms := false;
  FCurrentReference := AReference;
end;

function TMemoryDriver.MaxAvail(AXms: boolean): longint;
var
  index: integer;
  result: longint;
  reference: PReference;
  next: PReference;
  avail: longint;
  count: integer;
  offset: longint;
  size: longint;
  blockSize: longint;
  filtered: PList;
begin
  result := 0;
  if AXms then
    avail := FXmsSize
  else
    avail := FSwapSize;
  filtered := FReferences^.Where(IsXms, AXms);
  if filtered^.Count = 0 then
    MaxAvail := avail
  else if (filtered^.Count = 1) then begin
    reference := PReference(filtered^.GetItem(0));
    MaxAvail := avail - reference^.Size;
  end
  else begin
    for index := 0 to filtered^.Count - 1 do begin
      reference := filtered^.GetItem(index);
      offset := reference^.Offset;
      size := reference^.Size;
      { get the size between current reference and next }
      if (index + 1 < filtered^.Count - 1) then begin
        next := filtered^.GetItem(index + 1);
        blockSize := next^.Offset - (offset + size);
      end
      { no reference after the current, so return size between reference and max }
      else begin
        blockSize := avail - (offset + size);
      end;
      if (size > result) then
        result := size;
    end;
    MaxAvail := result;
  end;
  dispose(filtered, Free);
end;

function TMemoryDriver.Buffer: PByte;
begin
  Buffer := FBuffer;
end;

function TMemoryDriver.LowerMaxAvail: longint;
begin
  LowerMaxAvail := MaxAvail(false);
end;

function TMemoryDriver.LowerMemAvail: longint;
begin
  LowerMemAvail := FSwapSize - FLowerAllocated;
end;

function TMemoryDriver.XmsMemAvail: longint;
begin
  XmsMemAvail := FXmsSize - FXmsAllocated;
end;

function TMemoryDriver.XmsMaxAvail: longint;
begin
  XmsMaxAvail := MaxAvail(true);
end;

procedure TMemoryDriver.SetCurrentReference(AReference: PReference);
begin
  if FCurrentReference = AReference then
    exit;
  FCurrentReference := AReference;
  if not AReference^.Xms then
    exit;
  MoveToConventional(AReference);
end;

function TMemoryDriver.ReferencePointer(AReference: PReference): pointer;
var
  ptr: pointer;
  offset: longint;
begin
  SetCurrentReference(AReference);
  ptr := Buffer;
{  offset := Linear(ptr);
  Inc(offset, AReference^.Offset);
  ptr := LinearToPointer(offset);}
  ReferencePointer := ptr;
end;

function TMemoryDriver.XmsAlloc(ASize: longint): word;
var
  xmsResult: word;
  xmsError: byte;
  xmsSize: word;
  xmsHandle: word;
begin
  XmsAlloc := 0;
  xmsSize := ASize div 1024;
  xmsHandle := 0;
  xmsResult := 0;
  xmsError := 0;
  if (ASize mod 1024 > 0) then
    Inc(xmsSize, 1);
  asm
    push es
    push si
    mov  ah, 09h
    mov  dx, word ptr [xmsSize]
    call [XmsControl]
    mov  word ptr [xmsResult], ax
    mov  word ptr [xmsHandle], dx
    mov  byte ptr [xmsError], bl
    pop si
    pop es
  end;
  if (xmsError > 0) or (xmsResult = 0) then begin
    Raise(ecNotEnoughMemory);
    exit;
  end;
  XmsAlloc := xmsHandle;
end;

function TMemoryDriver.Alloc(ASize: longint): PReference;
var
  lowAvail: longint;
  xmsAvail: longint;
  reference: PReference;
begin
  if ASize = 0 then begin
    Raise(ecInvalidAllocSize);
    exit;
  end;
  reference := New(PReference);
  if reference = nil then begin
    Raise(ecNotEnoughMemory);
    Alloc := nil;
    exit;
  end;
  reference^.Size := ASize;
  reference^.Offset := 0;
  lowAvail := LowerMaxAvail;
  xmsAvail := XmsMaxAvail;
  if ASize <= lowAvail then begin
    reference^.Offset := GetNextOffset(ASize, false);
    reference^.Size := ASize;
    Inc(FLowerAllocated, ASize);
    reference^.Xms := false;
  end
  else if (XmsEnabled and (ASize <= xmsAvail)) then begin
    reference^.Offset := GetNextOffset(ASize, true);
    reference^.Size := ASize;
    Inc(FXmsAllocated, ASize);
    reference^.Xms := true;
  end
  else begin
    Raise(ecNotEnoughMemory);
    Dispose(reference);
    Alloc := nil;
    exit;
  end;
  FReferences^.Add(reference);
  if (FTransactionReferences <> nil) then
    FTransactionReferences^.Add(reference);
  Alloc := reference;
end;

procedure TMemoryDriver.FreeReference(AReference: PReference);
var
  xmsResult: word;
  xmsError: byte;
  xmsHandle: word;
  index: integer;
begin
  if AReference = nil then
    exit;
  index := FReferences^.IndexOf(AReference);
  if (index < 0) or (index > FReferences^.Count - 1) then
    exit;
  if not AReference^.Xms then
    Dec(FLowerAllocated, AReference^.Size)
  else
    Dec(FxmsAllocated, AReference^.Size);
  Dispose(AReference);
  FReferences^.Delete(index);
end;

procedure TMemoryDriver.Dealloc(var AReference: PReference);
begin
  FreeReference(AReference);
  AReference := nil;
end;

function TMemoryDriver.XmsVersion: real;
begin
  XmsVersion := FXmsVersion;
end;

destructor TMemoryDriver.Free;
var
  xmsHandle: word;
  reference: PReference;
begin
  FreeAndNil(OutOfMemoryException);
  while FReferences^.Count > 0 do begin
    reference := FReferences^.GetItem(0);
    FreeMem(reference, SizeOf(TReference));
    FReferences^.Delete(0);
  end;
  Dispose(FReferences, Free);
{  HugeFreeMem(pointer(FBuffer), FBufferSize);}
  xmsHandle := FXmsHandle;
  if XmsEnabled then begin
    asm
      mov ah, 0Ah
      mov dx, [xmsHandle]
      call [XmsControl]
    end;
  end;
  inherited Free;
end;

procedure TMemoryDriver.BeginAllocTransaction;
begin
  FTransactionReferences := New(PReferenceList, Create);
end;

procedure TMemoryDriver.Fill(AReference: PReference; AByte: byte);
var
  ptr: PByte;
begin
  ptr := ReferencePointer(AReference);
  FillByteLarge(ptr, AReference^.Size, AByte);
end;

procedure TMemoryDriver.CommitAllocTransaction;
begin
  Dispose(FTransactionReferences, Free);
  FTransactionReferences := nil;
end;

procedure TMemoryDriver.RollbackAllocTransaction;
var
  current: PReference;
begin
  if (FTransactionReferences = nil) then
    exit;
  while (FTransactionReferences^.Count > 0) do begin
    current := FReferences^.GetItem(0);
    FreeReference(current);
    FTransactionReferences^.Delete(0);
  end;
  Dispose(FTransactionReferences, Free);
end;

procedure TMemoryDriver.Init;
var
  reference: PReference;
  size: word;
begin
  inherited Init;
  OutOfMemoryException := New(PException, Create(ecNotEnoughMemory));
  { references are always sorted by Xms flag and Offset ascending }
  FReferences := New(PReferenceList, CreateSorted(ReferenceOffsetCompare));
  FCurrentReference := nil;
  FXmsVersion := 0;
  FXmsHandle := 0;
  FBuffer := nil;
  FLowerAllocated := 0;
  FXmsAllocated := 0;
  reference := nil;
  FXmsSize := 0;
  FTransactionReferences := nil;
  HeapError := @OnHeapError;
  XmsControl := nil;
  InitXms;
end;

function TMemoryDriver.GetTypeName;
begin
  GetTypeName := 'TMemoryDriver';
end;

procedure TReferenceList.Clear;
begin
  while Count > 0 do
    Delete(0);
end;

destructor TReferenceList.Free;
begin
  inherited Free;
end;

function TReferenceList.GetItem(AIndex: integer): PReference;
begin
  GetItem := TList.GetItem(AIndex);
end;

function TReferenceList.IndexOf(AItem: PReference): integer;
begin
  IndexOf := TList.IndexOf(AItem);
end;

function TReferenceList.Add(AItem: PReference): integer;
begin
  Add := TList.Add(AItem);
end;

procedure TReferenceList.Insert(AIndex: integer; AItem: PReference);
begin
  TList.Insert(AIndex, AItem);
end;

function TReferenceList.GetTypeName;
begin
  GetTypeName := 'TReferenceList';
end;

begin
end.